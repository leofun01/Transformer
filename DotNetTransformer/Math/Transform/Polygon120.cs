using System;
using System.Collections.Generic;
using System.Diagnostics;
using RotateFlipType = System.Drawing.RotateFlipType;
using DotNetTransformer.Math.Group;

namespace DotNetTransformer.Math.Transform {
	using T = Polygon120;

	[Serializable]
	[DebuggerDisplay("{ToString()}, CycleLength = {CycleLength}")]
	public struct Polygon120 : IFiniteGroupElement<T>
	{
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		public readonly byte Value;
		private Polygon120(byte value) { Value = value; }
		private Polygon120(int value) { Value = (byte)value; }

		private const byte _count = 240;
		private const byte _mod = 120;
		public static readonly FiniteGroup<T> AllValues;

		/// <summary> No changes | 360 degree rotation. </summary>
		public static T None { get { return new T(); } }
		/// <summary> Horizontal flip. Reflection across y-axis. </summary>
		public static T FlipX { get { return new T(1); } }
		/// <summary> Vertical flip. Reflection across x-axis. </summary>
		public static T FlipY { get { return new T(1 + _mod); } }

		static Polygon120() {
			AllValues = new DihedralGroupD120();
		}

		private sealed class DihedralGroupD120 : FiniteGroup<T>
		{
			public DihedralGroupD120() { }

			public override T IdentityElement { get { return None; } }
			public override int Count { get { return _count; } }
			public override bool Contains(T item) { return true; }
			public override IEnumerator<T> GetEnumerator() {
				for(byte i = 0; i < _count; ++i)
					yield return new T(i);
			}
			public override int GetHashCode() { return _count; }
		}

		/// <summary><return>
		/// <para>true for reflections (flip + rotation);</para>
		/// <para>false for rotations.</para>
		/// </return></summary>
		public bool IsReflection { get { return (Value & 1) == 1; } }
		/// <summary><return>
		/// <para>true for rotations;</para>
		/// <para>false for reflections (flip + rotation).</para>
		/// </return></summary>
		public bool IsRotation { get { return (Value & 1) == 0; } }

		/// <summary>
		/// The order of a cyclic group that can be generated by this element.
		/// </summary>
		public int CycleLength {
			get {
				if(IsReflection) return 2;
				/*//
				int r = 1;
				if(Value % 0x04 == 0) r *= 2;
				if(Value % 0x06 == 0) r *= 3;
				if(Value % 0x08 == 0) r *= 2;
				if(Value % 0x0A == 0) r *= 5;
				if(Value % 0x10 == 0) r *= 2;
				return _mod / r;
				/*/
				int r = _mod;
				if(Value % 0x06 == 0) r &= 0x28;
				if(Value % 0x0A == 0) r &= 0x18;
				if((Value & 0x02) == 0) r >>= 1;
				if((Value & 0x06) == 0) r >>= 1;
				if((Value & 0x0E) == 0) r >>= 1;
				return r;
				//*/
			}
		}
		public T InverseElement {
			get {
				if(IsReflection || Value == 0) return this;
				return new T(_count - Value);
			}
		}
		public T Add(T other) {
			int o = (other.Value & -2), f = (Value ^ other.Value) & 1;
			if(IsReflection) o = _count - o;
			return new T(((Value & -2) + o) % _count ^ f);
		}
		public T Subtract(T other) {
			int o = (other.Value & -2), f = (Value ^ other.Value) & 1;
			if(f == 0) o = _count - o;
			return new T(((Value & -2) + o) % _count ^ f);
		}
		public T Times(int count) {
			if(IsReflection) return new T((count & 1) * Value);
			return new T((count % _mod + _mod) * Value % _count);
		}

		public override int GetHashCode() { return Value; }
		public override bool Equals(object o) { return o is T && Equals((T)o); }
		public bool Equals(T o) { return Value == o.Value; }
		public override string ToString() {
			int v = (Value >> 1) * 3;
			if(v == 0) return Value == 0 ? "NO" : "FX";
			return string.Format(IsReflection ? "FX+R{0:000}" : "R{1:000}", 360 - v, v);
		}

		///	<exception cref="ArgumentException">
		///		<exception cref="ArgumentNullException">
		///			Invalid <paramref name="name"/>.
		///		</exception>
		///	</exception>
		public static T FromString(string name) {
			if(ReferenceEquals(name, null)) throw new ArgumentNullException();
			if(name == "NO") return None;
			if(name == "FX") return FlipX;
			if(name.StartsWith("FX+R") || name.StartsWith("R")) {
				int start = name.IndexOf('R') + 1;
				if(start + 3 == name.Length) {
					int degree = 0;
					bool ok = true;
					for(int i = 0; i < 3; ++i) {
						char ch = name[start + i];
						ok &= ch >= '0' && ch <= '9';
						degree = degree * 10 + ch - '0';
					}
					if(ok) {
						T r = CreateRotation(degree);
						return start == 4 ? FlipX.Add(r) : r;
					}
				}
			}
			throw new ArgumentException(
				string.Format("\"{0}\" is not found.", name
					.Replace("\\", "\\\\")
					.Replace("\"", "\\\"")
				), "name"
			);
		}
		public static T FromInt32(int value) {
			return new T((value % _count + _count) % _count);
		}
		public static T FromFlipRotate2D(FlipRotate2D value) {
			/*//
			return FromRotateFlipType(value.ToRotateFlipType());
			int v = value.Value;
			v = (v << 1) | (v >> 2);
			return new T((v & 3) * 60 ^ (((v + 4) >> 3) & 1));
			/*/
			int v = 0x62735140 >> (value.Value << 2);
			return new T((v & 6) * 30 ^ (v & 1));
			//*/
		}
		public static T FromRotateFlipType(RotateFlipType value) {
			int v = (int)value;
			return new T((v & 3) * 60 ^ (v >> 2));
		}
		public static T CreateRotation(int degree) {
			return new T((degree % 360 + 361) % 360 / 3 << 1);
		}
		public static T CreateRotation(float radian) {
			const float p = 6.2831853f, e = p / _count;
			return new T((int)((radian % p + p + e) / p * _mod) % _mod << 1);
		}

		public static bool operator ==(T l, T r) { return l.Equals(r); }
		public static bool operator !=(T l, T r) { return !l.Equals(r); }

		public static T operator +(T o) { return o; }
		public static T operator -(T o) { return o.InverseElement; }
		public static T operator +(T l, T r) { return l.Add(r); }
		public static T operator -(T l, T r) { return l.Subtract(r); }
		public static T operator *(T l, int r) { return l.Times(r); }
		public static T operator *(int l, T r) { return r.Times(l); }

		public static explicit operator T(int o) { return FromInt32(o); }
		public static implicit operator T(FlipRotate2D o) { return FromFlipRotate2D(o); }
		public static implicit operator T(RotateFlipType o) { return FromRotateFlipType(o); }
	}
}
